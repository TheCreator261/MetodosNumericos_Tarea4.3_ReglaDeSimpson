# -*- coding: utf-8 -*-
"""Tarea 4.3 Regla de Simpson.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1elu8Afk-ioPIt-OFob-0xC7uSjJOdpke
"""

#Antonio Josue Rodriguez Falcon
#Ejercicio 1

import numpy as np
import matplotlib.pyplot as plt

def simpson_rule(f, a, b, n):
    """Aproxima la integral de f(x) en [a, b] usando la regla de Simpson."""
    if n % 2 == 1:
        raise ValueError("El número de subintervalos (n) debe ser par.")

    h = (b - a) / n
    x = np.linspace(a, b, n + 1)  # Puntos del intervalo
    fx = f(x)  # Evaluamos la función en esos puntos

    # Regla de Simpson
    integral = (h / 3) * (fx[0] + 2 * np.sum(fx[2:n:2]) + 4 * np.sum(fx[1:n:2]) + fx[n])

    return integral

# Ejercicio 1: Cálculo del trabajo en un resorte
def trabajo_resorte(x):
    k = 200  # N/m
    return k * x

a_resorte = 0.1  # m
b_resorte = 0.3  # m
n_resorte_values = [6, 10, 20, 30]

print("Ejercicio 1 - Trabajo del resorte:")
for n_resorte in n_resorte_values:
    resultado_resorte = simpson_rule(trabajo_resorte, a_resorte, b_resorte, n_resorte)
    print(f"  n = {n_resorte}: {resultado_resorte} Joules")

# Gráfica del Ejercicio 1
x_resorte = np.linspace(a_resorte, b_resorte, 100)
y_resorte = trabajo_resorte(x_resorte)

plt.plot(x_resorte, y_resorte, label="Trabajo del resorte", color="blue")
plt.fill_between(x_resorte, y_resorte, alpha=0.3, color="cyan", label="Área aproximada")
plt.xlabel("x (m)")
plt.ylabel("Fuerza (N)")
plt.title("Trabajo realizado por un resorte")
plt.grid()
plt.savefig("resorte_varios_n.png")
plt.show()

#Ejercicio 2

import numpy as np
import matplotlib.pyplot as plt

def simpson_rule(f, a, b, n):
    """Aproxima la integral de f(x) en [a, b] usando la regla de Simpson."""
    if n % 2 == 1:
        raise ValueError("El número de subintervalos (n) debe ser par.")

    h = (b - a) / n
    x = np.linspace(a, b, n + 1)  # Puntos del intervalo
    fx = f(x)  # Evaluamos la función en esos puntos

    # Regla de Simpson
    integral = (h / 3) * (fx[0] + 2 * np.sum(fx[2:n:2]) + 4 * np.sum(fx[1:n:2]) + fx[n])

    return integral

# Ejercicio 2: Cálculo de la carga eléctrica en un capacitor
def voltaje_capacitor(t):
    C = 1e-6  # F
    V_t = 100 * np.exp(-2 * t)  # V
    return C * V_t

a_capacitor = 0  # s
b_capacitor = 5  # s
n_capacitor_values = [6, 10, 20, 30]

print("\nEjercicio 2 - Carga del capacitor:")
for n_capacitor in n_capacitor_values:
    resultado_capacitor = simpson_rule(voltaje_capacitor, a_capacitor, b_capacitor, n_capacitor)
    print(f"  n = {n_capacitor}: {resultado_capacitor} Coulombs")

# Gráfica del Ejercicio 2
t_capacitor = np.linspace(a_capacitor, b_capacitor, 100)
Q_t = voltaje_capacitor(t_capacitor)

plt.plot(t_capacitor, Q_t, label="Carga del capacitor", color="green")
plt.fill_between(t_capacitor, Q_t, alpha=0.3, color="lime", label="Área aproximada")
plt.xlabel("Tiempo (s)")
plt.ylabel("Carga (C)")
plt.title("Carga almacenada en un capacitor")
plt.grid()
plt.savefig("capacitor_varios_n.png")
plt.show()

#Ejercicio 3

import numpy as np
import matplotlib.pyplot as plt

def simpson_rule(f, a, b, n):
    """Aproxima la integral de f(x) en [a, b] usando la regla de Simpson."""
    if n % 2 == 1:
        raise ValueError("El número de subintervalos (n) debe ser par.")

    h = (b - a) / n
    x = np.linspace(a, b, n + 1)  # Puntos del intervalo
    fx = f(x)  # Evaluamos la función en esos puntos

    # Regla de Simpson
    integral = (h / 3) * (fx[0] + 2 * np.sum(fx[2:n:2]) + 4 * np.sum(fx[1:n:2]) + fx[n])

    return integral

# Ejercicio 3: Flujo de calor a través de una pared
def flujo_calor(x):
    k = 0.5  # W/m·K
    dT_dx = -100 * x
    return k * dT_dx

a_calor = 0  # m
b_calor = 2  # m
n_calor_values = [6, 10, 20, 30]

print("\nEjercicio 3 - Flujo de calor:")
for n_calor in n_calor_values:
    resultado_calor = simpson_rule(flujo_calor, a_calor, b_calor, n_calor)
    print(f"  n = {n_calor}: {resultado_calor} Watts")

# Gráfica del Ejercicio 3
x_calor = np.linspace(a_calor, b_calor, 100)
Q_x = flujo_calor(x_calor)

plt.plot(x_calor, Q_x, label="Flujo de calor", color="red")
plt.fill_between(x_calor, Q_x, alpha=0.3, color="salmon", label="Área aproximada")
plt.xlabel("Posición (m)")
plt.ylabel("Flujo de calor (W)")
plt.title("Flujo de calor a través de una pared")
plt.grid()
plt.savefig("calor_varios_n.png")
plt.show()